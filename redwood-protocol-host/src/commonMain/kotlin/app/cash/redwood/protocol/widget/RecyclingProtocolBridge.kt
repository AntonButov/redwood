/*
 * Copyright (C) 2024 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package app.cash.redwood.protocol.widget

import app.cash.redwood.Modifier
import app.cash.redwood.RedwoodCodegenApi
import app.cash.redwood.protocol.Change
import app.cash.redwood.protocol.ChangesSink
import app.cash.redwood.protocol.ChildrenChange
import app.cash.redwood.protocol.Create
import app.cash.redwood.protocol.EventSink
import app.cash.redwood.protocol.Id
import app.cash.redwood.protocol.ModifierChange
import app.cash.redwood.protocol.PropertyChange
import app.cash.redwood.protocol.WidgetTag
import app.cash.redwood.widget.ChangeListener
import app.cash.redwood.widget.Widget
import kotlin.native.ObjCName

/**
 * Copy-paste of [ProtocolBridge] that also supports recycling.
 */
@OptIn(RedwoodCodegenApi::class)
@ObjCName("ProtocolBridge", exact = true)
public class RecyclingProtocolBridge<W : Any>(
  container: Widget.Children<W>,
  factory: ProtocolFactory<W>,
  private val eventSink: EventSink,
  // TODO: this should come from the protocol, not from the caller.
  private val tagToReuseId: (WidgetTag) -> ReuseId?,
) : ChangesSink {
  private val factory = requireNotNull(factory as? GeneratedProtocolFactory<W>) {
    "Factory ${factory::class} was not generated by Redwood or is out of date"
  }

  private val nodes = mutableMapOf<Id, ProtocolNode<W>>(
    Id.Root to RootProtocolNode(container),
  )

  private val changedWidgets = mutableSetOf<ChangeListener>()

  private val pool = mutableMapOf<ReuseId, ArrayDeque<ProtocolNode<W>>>()

  override fun sendChanges(changes: List<Change>) {
    for (i in changes.indices) {
      val change = changes[i]
      val id = change.id
      when (change) {
        is Create -> {

          // Return a node from the pool instead.
          // This node is likely broken if it has child nodes.
          val reuseId = tagToReuseId(change.tag)
          val pooledNode = pool[reuseId]?.removeFirstOrNull()
          if (pooledNode != null) {
            val old = nodes.put(change.id, pooledNode)
            require(old == null) {
              "Insert attempted to replace existing widget with ID ${change.id.value}"
            }
            continue
          }

          val node = factory.createNode(change.tag) ?: continue
          node.reuseId = reuseId
          val old = nodes.put(change.id, node)
          require(old == null) {
            "Insert attempted to replace existing widget with ID ${change.id.value}"
          }
        }

        is ChildrenChange -> {
          val node = node(id)
          val children = node.children(change.tag) ?: continue
          when (change) {
            is ChildrenChange.Add -> {
              val child = node(change.childId)
              children.insert(change.index, child)
            }

            is ChildrenChange.Move -> {
              children.move(change.fromIndex, change.toIndex, change.count)
            }

            is ChildrenChange.Remove -> {
              children.remove(change.index, change.count)

              // Remove elements from [nodes]. Also pool them if they're eligible.
              for (removedId in change.removedIds) {
                val removedNode = nodes.remove(removedId)!!
                val reuseId = removedNode.reuseId
                if (reuseId != null) {
                  pool.getOrPut(reuseId) { ArrayDeque() }.addLast(removedNode)
                }
              }
            }
          }

          val widget = node.widget
          if (widget is ChangeListener) {
            changedWidgets += widget
          }
        }

        is ModifierChange -> {
          val modifier = change.elements.fold<_, Modifier>(Modifier) { modifier, element ->
            modifier.then(factory.createModifier(element))
          }
          val node = node(id)
          node.updateModifier(modifier)

          val widget = node.widget
          if (widget is ChangeListener) {
            changedWidgets += widget
          }
        }

        is PropertyChange -> {
          val node = node(change.id)
          node.apply(change, eventSink)

          val widget = node.widget
          if (widget is ChangeListener) {
            changedWidgets += widget
          }
        }
      }
    }

    if (changedWidgets.isNotEmpty()) {
      for (widget in changedWidgets) {
        widget.onEndChanges()
      }
      changedWidgets.clear()
    }
  }

  private fun node(id: Id): ProtocolNode<W> {
    return checkNotNull(nodes[id]) { "Unknown widget ID ${id.value}" }
  }
}
